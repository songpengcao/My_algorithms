# 并查集

首先考虑两种操作：

1. 将两个集合合并
2. 询问两个元素是否在一个集合中



一种朴素的方式是利用数组 belongto[a] = x，代表元素a属于集合x。这时进行第2个操作时间复杂度为 $O(1)$ ，而第1个操作需要将一个集合的所有元素进行修改，时间复杂度为 $O(n)$。



并查集是一种对集合操作的高效数据结构。可以在几乎 $O(1)$ 复杂度的情况下支持以上两个操作。



## 基本思想

每个集合用一棵树表示，树根的编号就是整个集合的编号。

每个节点存储它的父节点，p[x]表示x的父节点。



三种常见操作：

1. 如何判断树根

   ```c++
   (p[x] == x)
   ```

2. 如何求x的集合编号

   ```c++
   while (p[x] != x) x = p[x];
   ```

3. 如何合并两个集合

   ```c++
   // p[x] 是x集合编号
   // p[y] 是y集合编号
   p[x] = y;
   ```

   

## 时间复杂度分析

观察这两个操作不难发现，每个操作都需要去寻找该元素集合的树根。这个过程最坏的可能是树退化为一个链表，需要找n次才能找到该集合对应的编号。即时间复杂度为 $O(n)$ 。



## 优化：路径压缩

在递归查找的过程中将所有的节点都指向根节点，从而让后续的查找过程复杂度降低到 $O(1)$。
